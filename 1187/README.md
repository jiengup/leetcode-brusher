## 题面
```
给你两个整数数组 arr1 和 arr2，返回使 arr1 严格递增所需要的最小「操作」数（可能为 0）。

每一步「操作」中，你可以分别从 arr1 和 arr2 中各选出一个索引，分别为 i 和 j，0 <= i < arr1.length 和 0 <= j < arr2.length，然后进行赋值运算 arr1[i] = arr2[j]。

如果无法让 arr1 严格递增，请返回 -1。

 

示例 1：

输入：arr1 = [1,5,3,6,7], arr2 = [1,3,2,4]
输出：1
解释：用 2 来替换 5，之后 arr1 = [1, 2, 3, 6, 7]。
示例 2：

输入：arr1 = [1,5,3,6,7], arr2 = [4,3,1]
输出：2
解释：用 3 来替换 5，然后用 4 来替换 3，得到 arr1 = [1, 3, 4, 6, 7]。
示例 3：

输入：arr1 = [1,5,3,6,7], arr2 = [1,6,3,3]
输出：-1
解释：无法使 arr1 严格递增。
 

提示：

1 <= arr1.length, arr2.length <= 2000
0 <= arr1[i], arr2[i] <= 10^9
```

## 题解
最长递增子序列（LCS）的变体

简单来说，一步操作是使用arr2中的一个数替换arr1中的一个数。
很自然地，我们可以对arr1从头到尾进行这个过程，对每一个值进行操作（或者不操作），从而由部分有序构建全体有序。
考虑进行到arr1[i]时，此时0~i-1已经有序，此时我们面临两种选择：

不进行替换，前提是arr1[i]>arr1[i-1]\(注意是替换后的arr1[i-1])，操作数不变。
进行替换，就要考虑用哪个数来替换，此时采用贪心的思想：首先，这个数必须比arr1[i-1]大以保证有序，在这个前提下，越小越好，这也是很显然的。所以，我们希望找到arr2中比arr1[i-1]大的最小值进行替换，使用排序+二分查找，操作数+1。
需要指出，在已经递增的情况下，执行替换也可能更好，因为可以使末位变小。实际上，我们就是要在最后一个数更小和操作数更少之间进行取舍，也依此来定义状态。
有了这样的思路，可以开始设计dp了。

第一种dp——最后一个数固定时的最小操作数
根据上面的思路，**定义dp[i][j]为：对于前i个数构成的递增序列，在最后一个数为j时的最小操作数。**
状态转移方程：

$$
dp[i][arr[i]]=min(dp[i−1][j]),j<arr[i] \\
dp[i][k]=min(dp[i−1][j])+1,best of j is k
$$
简单来说，对于每一个dp[i-1][j]，如果j < arr1[i]，则可以转移到dp[i][arr1[i]]并且操作数不变（不进行转化）；而对于每一个j，如果二分查找成功在arr2中找到k，那就可以转移到dp[i][k]，并且操作数+1。

因为状态转移只发生在相邻两个数组之间，可以优化掉一维，改用两个一维数组实现。

在代码实现上，由于最后一个数是不连续的，要用哈希表作为dp数组；dp[i]表示当前序列最后一个数为i时的最小操作数，我们从头到尾遍历arr1，并对上一个哈希表内的状态进行转移即可。
不同的值最多m+n个，因此这种方法的时间复杂度为O(n*(m+n)*logm)